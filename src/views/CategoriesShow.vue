<template>
  <div class="categories-show wrapper">

    <div class="page-header page-header-small">


        <div class="page-header-image" data-parallax="true" style="background-image: url('/assets/img/bg44.jpg') ;">
        </div>



        <div class="content-center">
        <div class="row">
          <div class="col-md-8 ml-auto mr-auto text-center">
            <h2 class="title">A Place for Entrepreneurs to Share and Discover New Stories</h2>
                    <a href="#button" class="btn btn-primary btn-round  btn-icon" >
                   <i class="fa fa-twitter"></i>
                </a>
                <a href="#button" class="btn btn-primary btn-round  btn-icon">
                   <i class="fa fa-instagram"></i>
               </a>
          </div>
        </div>
      </div>
      <div>
        <div :class="inputClass + ' tags-input'">
            <span class="badge badge-pill badge-light"
                v-for="(badge, index) in tagBadges"
                :key="index"
            >
                <span v-html="badge"></span>

                <i href="#" class="tags-input-remove" @click.prevent="removeTag(index)"></i>
            </span>

            <input type="text"
                ref="taginput"
                :placeholder="placeholder"
                v-model="input"
                @keydown.enter.prevent="tagFromInput"
                @keydown.8="removeLastTag"
                @keydown.down="nextSearchResult"
                @keydown.up="prevSearchResult"
                @keyup.esc="ignoreSearchResults"
                @keyup="searchTag"
                @focus="onFocus"
                @blur="hideTypeahead"
                @value="tags">

            <input type="hidden" v-if="elementId"
                :name="elementId"
                :id="elementId"
                v-model="hiddenInput">
        </div>

        <p v-show="searchResults.length" class="typeahead">
            <span v-for="(tag, index) in searchResults"
                :key="index"
                v-text="tag.text"
                @mousedown.prevent="tagFromSearchOnClick(tag)"
                class="badge"
                v-bind:class="{
                    'badge-primary': index == searchSelection,
                    'badge-dark': index != searchSelection
                }"></span>
        </p>
    </div>

    </div>



<div class="main">

    <div class="container">
        <div class="section">
            <h3 class="title text-center">Goals</h3>
            <br />
            <div class="row">
                <div v-for="goal in category.goals" class="col-md-4">
                    <div class="card card-plain card-blog">
                        <div class="card-image">
                            <a href="#pablo">
                                <img class="img rounded img-raised" v-bind:src="goal.image" />
                            </a>
                        </div>

                        <div class="card-body">
                            <h6 class="category text-info">{{ category.name }}</h6>
                            <h4 class="card-title">
                                <a href="#pablo">{{ goal.title }}</a>
                            </h4>
                            <p class="card-description">
                                {{ goal.description }}<a href="#pablo"> Read More </a>

                                <div class="author">
                                    <img src="/assets/img/olivia.jpg" alt="..." class="avatar img-raised">
                                    <span>Anna Spark</span>
                                </div>
                            </p>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>
</div>


<!--       <h2>{{ category.name }}</h2> -->
      <!-- <p>{{ category.goals }}</p> -->
      <div v-for="goal in category.goals">
        <h4>{{ goal.title }}</h4>
      </div>
      <a href="/#/categories">Back to all categories</a>
    </div>
  </div>
</template>

<script>
var axios = require("axios");
// import axios from "axios";

export default {
  props: {
    elementId: String,

    inputClass: {
      type: String,
      default: "tags-input-default-class"
    },

    existingTags: {
      type: Object,
      default: () => {
        return {};
      }
    },

    value: {
      type: [Array, String],
      default: () => {
        return [];
      }
    },

    typeahead: {
      type: Boolean,
      default: false
    },

    typeaheadActivationThreshold: {
      type: Number,
      default: 1
    },

    typeaheadMaxResults: {
      type: Number,
      default: 0
    },

    placeholder: {
      type: String,
      default: "Add a tag"
    },

    limit: {
      type: Number,
      default: 0
    },

    onlyExistingTags: {
      type: Boolean,
      default: false
    },

    deleteOnBackspace: {
      type: Boolean,
      default: true
    },

    allowDuplicates: {
      type: Boolean,
      default: false
    },

    validate: {
      type: Function,
      default: () => true
    },

    data: function() {
      return {
        category: {},
        errors: [],
        badgeId: 0,
        tagBadges: [],
        tags: [],

        input: "",
        oldInput: "",
        hiddenInput: "",

        searchResults: [],
        searchSelection: 0
      };
    },
    created: function() {
      this.tagsFromValue();
      axios
        .get("http://localhost:3000/api/categories/" + this.$route.params.id)
        .then(response => {
          console.log(response);
          this.category = response.data;
        });
    },
    watch: {
      tags() {
        // Updating the hidden input
        this.hiddenInput = this.tags.join(",");
        // Update the bound v-model value
        this.$emit("input", this.tags);
      },
      value() {
        this.tagsFromValue();
      }
    },
    methods: {
        escapeRegExp(string) {
          return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        },

        tagFromInput() {
          // If we're choosing a tag from the search results
          if (this.searchResults.length && this.searchSelection >= 0) {
            this.tagFromSearch(this.searchResults[this.searchSelection]);

            this.input = "";
          } else {
            // If we're adding an unexisting tag
            let text = this.input.trim();

            // If the new tag is not an empty string and passes validation
            if (!this.onlyExistingTags && text.length && this.validate(text)) {
              this.input = "";

              // Determine the tag's slug and text depending on if the tag exists
              // on the site already or not
              let slug = this.makeSlug(text);
              let existingTag = this.existingTags[slug];

              slug = existingTag ? slug : text;
              text = existingTag ? existingTag : text;

              this.addTag(slug, text);
            }
          }
        },

        tagFromSearchOnClick(tag) {
          this.tagFromSearch(tag);

          this.$refs["taginput"].blur();
        },

        tagFromSearch(tag) {
          this.searchResults = [];
          this.input = "";
          this.oldInput = "";

          this.addTag(tag.slug, tag.text);
        },

        makeSlug(value) {
          return value.toLowerCase().replace(/\s/g, "-");
        },

        addTag(slug, text) {
          // Check if the limit has been reached
          if (this.limit > 0 && this.tags.length >= this.limit) {
            return false;
          }

          // Attach the tag if it hasn't been attached yet
          if (!this.tagSelected(slug)) {
            this.tagBadges.push(text.replace(/\s/g, "&nbsp;"));
            this.tags.push(slug);
          }
        },

        removeLastTag() {
          if (!this.input.length && this.deleteOnBackspace) {
            this.removeTag(this.tags.length - 1);
          }
        },

        removeTag(index) {
          this.tags.splice(index, 1);
          this.tagBadges.splice(index, 1);
        },

        searchTag() {
          if (this.typeahead === true) {
            if (
              this.oldInput != this.input ||
              (!this.searchResults.length && this.typeaheadActivationThreshold == 0)
            ) {
              this.searchResults = [];
              this.searchSelection = 0;
              let input = this.input.trim();

              if (
                (input.length &&
                  input.length >= this.typeaheadActivationThreshold) ||
                this.typeaheadActivationThreshold == 0
              ) {
                for (let slug in this.existingTags) {
                  let text = this.existingTags[slug].toLowerCase();

                  if (
                    text.search(this.escapeRegExp(input.toLowerCase())) > -1 &&
                    !this.tagSelected(slug)
                  ) {
                    this.searchResults.push({
                      slug,
                      text: this.existingTags[slug]
                    });
                  }
                }

                // Sort the search results alphabetically
                this.searchResults.sort((a, b) => {
                  if (a.text < b.text) return -1;
                  if (a.text > b.text) return 1;

                  return 0;
                });

                // Shorten Search results to desired length
                if (this.typeaheadMaxResults > 0) {
                  this.searchResults = this.searchResults.slice(
                    0,
                    this.typeaheadMaxResults
                  );
                }
              }

              this.oldInput = this.input;
            }
          }
        },

        onFocus() {
          this.searchTag();
        },

        hideTypeahead() {
          if (!this.input.length) {
            this.$nextTick(() => {
              this.ignoreSearchResults();
            });
          }
        },

        nextSearchResult() {
          if (this.searchSelection + 1 <= this.searchResults.length - 1) {
            this.searchSelection++;
          }
        },

        prevSearchResult() {
          if (this.searchSelection > 0) {
            this.searchSelection--;
          }
        },

        ignoreSearchResults() {
          this.searchResults = [];
          this.searchSelection = 0;
        },

        /**
         * Clear the list of selected tags
         */
        clearTags() {
          this.tags.splice(0, this.tags.length);
          this.tagBadges.splice(0, this.tagBadges.length);
        },

        /**
         * Replace the currently selected tags with the tags from the value
         */
        tagsFromValue() {
          if (this.value && this.value.length) {
            let tags = Array.isArray(this.value)
              ? this.value
              : this.value.split(",");

            if (this.tags == tags) {
              return;
            }

            this.clearTags();

            for (let slug of tags) {
              let existingTag = this.existingTags[slug];
              let text = existingTag ? existingTag : slug;

              this.addTag(slug, text);
            }
          } else {
            if (this.tags.length == 0) {
              return;
            }

            this.clearTags();
          }
        },

        /**
         * Check if the tag with the provided slug is already selected
         */
        tagSelected(slug) {
          if (this.allowDuplicates) {
            return false;
          }

          if (!slug) {
            return false;
          }

          let searchSlug = this.makeSlug(slug);
          let found = this.tags.find(value => {
            return searchSlug == this.makeSlug(value);
          });

          return !!found;
        },
      
    },
},
</script>


<style>
/* tags-input */
.tags-input {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
}

.tags-input input {
  flex: 1;
  background: transparent;
  border: none;
}

.tags-input span {
  margin-right: 0.3rem;
  margin-bottom: 0.2rem;
}

.typeahead > span {
  cursor: pointer;
  margin-right: 0.3rem;
}
</style>
